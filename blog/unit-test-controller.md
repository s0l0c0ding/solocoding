---
published: true
title: How to make a unit test to a @Controller class
description: In this article, we are going to see how to make a unit test to a @Controller annotated class. This means we are going to isolate it from the spring context.
date: 2020-05-24
author: Bassem
slug: eng_spring_how_to_make_unit_controller_class
photo: assets/stock/code.webp
imgCredit: Markus Spiske on Unsplash
keywords:
  - spring test
  - spring
language: en
output:
  html_document:
    css: post-details.component.css
---

In this article, we are going to see how to make a unit test to a @Controller annotated class. This means we are going to isolate it from the spring context. 
<br>
Normally when we test our application with [@SpringBootTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html) , we are making an integration test, as we are using SpringBootContextLoader as the default ContextLoader, initiating all the beans in our application. 
<br>  
Worth mentioning that spring framework provide also other annotations which allow us to slice the context. For example [@WebMvcTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html) for testing the web layer, where we can choose a specific controller to be checked, [@DataJpaTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/DataJpaTest.html) for testing the JPA and the data base layer, a complete list can be found [here](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-test-auto-configuration.html#test-auto-configuration).
<br>  
So first thing, we are going to make a RestController which will present the following Post object : 
```java
public class Post {

    private String id;
    private String postTitle;
    private String body;

    public Post (String postTitle, String body) {
        this.id = UUID.randomUUID().toString();
        this.postTitle = postTitle;
        this.body = body;
    }
    // getters and setters
}
```
Nothing fancy there, we have three private properties and we are simulating the id generated by a random UUID.  
<br> 
Next we have our controller:
```java

@RestController
public class PostController {
   
    @GetMapping("/post/{random}")
    public Post getPost(@PathVariable Integer random) {
        return new Post("postTitle "+ random, "some body");
    }


}
```
Our class in annotated with [@RestController](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html), which will consent us wrap the generated post in a response body automatically, that happens because the annotation it self is annotated with [@ResponseBody](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseBody.html).
<br>
Then we have our method, where we return a new post with a post title
concatenated with a number exchanged throw the [@PathVariable](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html). Finally the end point is exposed throw a http get by using the [@GetMapping](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/GetMapping.html) annotation.
<br>
Next let's see our test :
```java
@ExtendWith(SpringExtension.class)
class UnitestcontrollerApplicationTests {

	private static MockMvc mockMvc;

	@BeforeAll
	static void init () {
		mockMvc = MockMvcBuilders.standaloneSetup(PostController.class).build();
	}

	@Test
	void testController() throws Exception {
		mockMvc.perform(get("/post/1")).andDo(print()).andExpect(status().isOk());
	}
	
	@Test
	void shouldGive405ForPost() throws Exception {
		mockMvc.perform(post("/post/1")).andDo(print()).andExpect(status().isMethodNotAllowed());
	}

}
```
Our test class is annotated with [@ExtendWith(SpringExtension.class)](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/junit/jupiter/SpringExtension.html) , in this way we are integrating the Spring TestContext Framework into JUnit 5, so we are using some overridden junit methods like beforAll, afterAll, etc. 
<br>
In addition we could  use the [@MockBean](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/mock/mockito/MockBean.html) annotation to add mocks to our context and finally we gain access to the ApplicationContext associated with the test. In fact if we take a look at the logging messages during the test, we can note that our contextInitializerClasses array is empty:
```markup
[main] DEBUG org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate - Storing ApplicationContext [1808884231] in cache under key [[MergedContextConfiguration@510f3d34 testClass = UnitestcontrollerApplicationTests, locations = '{}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', 
```
To read more about caching the application context, take a look at the official docs [here](https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-caching).  
<br>
Next we have the [MockMvc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html) object, the main tool to test our controller class, it's a static variable, so we can initiate it in the @BeforeAll method:
```java
private static MockMvc mockMvc;

@BeforeAll
static void init () {
		mockMvc = MockMvcBuilders.standaloneSetup(PostController.class).build();
	}
```
We are making a custom build for our mockMvc object with MockMvcBuilders, so we can start our test with the minimum infrastructure required and we are also testing just one controller (can accept also an array).  
<br>
Next, let's take a look at our tests:
```java
@Test
	void testController() throws Exception {
		mockMvc.perform(get("/post/1")).andDo(print()).andExpect(status().isOk());
	}
	
	@Test
	void shouldGive405ForPost() throws Exception {
		mockMvc.perform(post("/post/1")).andDo(print()).andExpect(status().isMethodNotAllowed());
	}
```
Nothing fancy there, we are making sure that our end point is working with first test and that is accepting only get requests with the second one. 
<br>
Now let's us introduce a complication our controller by injecting a service, which will be responsible for generating the new post, the result will be as follow:
```java
@RestController
public class PostController {

    private final PostService service;

    public PostController(PostService service) {
        this.service = service;
    }
    @GetMapping("/post/{random}")
    public Post getPost(@PathVariable Integer random) {
        return service.getAPost(random);
    }
}
```
So we need to change our test to integrate the new modification, as following:
```java
@ExtendWith(SpringExtension.class)
class UnitestcontrollerApplicationTests {

	private static MockMvc mockMvc;
	private static PostService service = mock(PostService.class);

	@BeforeAll
	static void init () {
		mockMvc = MockMvcBuilders.standaloneSetup(new PostController(service)).build();
	}

	@Test
	void testController() throws Exception {
		when(service.getAPost(1)).thenReturn(new Post("postTitle", "body"));
		mockMvc.perform(get("/post/1")).andDo(print()).andExpect(status().isOk());
	}
	
	@Test
	void shouldGive405ForPost() throws Exception {
		when(service.getAPost(1)).thenReturn(new Post("postTitle", "body"));
		mockMvc.perform(post("/post/1")).andDo(print()).andExpect(status().isMethodNotAllowed());
	}

}
```
As you can see, we mocked the postService using static method mock() of Mockito, we could also use @MockBean, as we are using the SpringExtension.class.
Then we constructed our controller object using the mock just created.
Also in each test we are returning a mock response using when(..).thenReturn(..) statement of Mockito.  
<br>
Finally, if we want to get rid of all the Spring dependencies and use only Mockito (as our test) , we have only to remove the @ExtendWith(SpringExtension.class). In this way we have a true junit test.  
<br>
That's it; all the code written in this post can be found on [GitHub](https://github.com/s0l0c0ding/spring-tips/tree/master/unitestcontroller).
<br>
<div class="embed-responsive embed-responsive-16by9">
  <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/Z59mGG6gVfk" allowfullscreen></iframe>
</div>
<br>
